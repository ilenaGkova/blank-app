import random
from check_and_balance import get_status
from mongo_connection import User, Recommendation, Status, Recommendation_Per_Person
from generate_by_tags import generate_recommendations_chosen_by_tags
from generate_by_algorithm import generate_recommendations_by_algorithm
from create_prompt_by_AI import generate_recommendations_by_AI
from generate_items import get_maximum_entries


# This function returns the amount of entries of the recommendations generated in 3 different ways, and a condition that tells us whether it run the entire function correctly
def calculate_entries(passcode):
    if not User.find_one(
            {"Passcode": passcode}):  # If we can't find the user we can't generate recommendations for them

        return False, 0, 0, 0

    entries_required = User.find_one({"Passcode": passcode})[
        'Suggestions']  # Find the user using their Passcode and get their number of preferences

    if entries_required > Recommendation.count_documents(
            {}):  # If required recommendations can't be satisfied by the available recommendations we return 0s

        return False, 0, 0, 0

    # Set initial numbers

    entries_generated_by_AI = 0

    entries_chosen_by_Tags = 0

    entries_chosen_by_algorithm = 0

    while entries_generated_by_AI + entries_chosen_by_Tags + entries_chosen_by_algorithm < entries_required:

        entries_chosen_by_Tags, entries_chosen_by_algorithm, entries_generated_by_AI = add_category(
            entries_chosen_by_Tags, entries_chosen_by_algorithm, entries_generated_by_AI)

    return True, entries_chosen_by_algorithm, entries_chosen_by_Tags, entries_generated_by_AI  # Return all 3 numbers


def add_category(entries_chosen_by_Tags, entries_chosen_by_algorithm, entries_generated_by_AI):
    category = int(random.randint(0, 10))  # Add to a category at random until you get enough
    if category < 5:

        entries_generated_by_AI += 1

    elif category <= 8:

        entries_chosen_by_Tags += 1

    else:

        entries_chosen_by_algorithm += 1

    return entries_chosen_by_Tags, entries_chosen_by_algorithm, entries_generated_by_AI


# This function generates recommendations via varius methods for users
def get_recommendations(passcode):
    # The function has 3 returns
    # One is a message of the outcome of the function and the other is True/False
    # True means the function completed its task: generating recommendations for users as requested
    # It will also either return None or a dictionary list for the user that will be styled later

    if not User.find_one(
            {"Passcode": passcode}):  # If we can't find the user we can't generate recommendations for them

        return False, None, "Something went wrong, user not registered"

    if Recommendation.count_documents({}) == 0:  # If we don't have recommendations we can't return any to the user

        return False, None, 'There are no recommendations available for you.'

    # Find the last status the user made (look in the function for more) and make sure we enter the right amount if return variables

    today, yesterday, index = get_status(passcode)

    if not today:  # If the user hasn't made a status, we can't generate recommendations for them either

        return False, None, 'Something went wrong, status was not found'

    status = Status.find_one({"_id": index})  # Find the status to find the timestamp

    latest_recommendation = Recommendation_Per_Person.find_one({"Passcode": passcode}, sort=[
        ("Created_At", -1)])  # Get the last recommendation given to match with the status

    if latest_recommendation and status['Created_At'] == latest_recommendation['Status_Created_At']:
        # If matched that means recommendations have been gathered for the user, and we can return them instead

        return True, list(
            Recommendation_Per_Person.find({"Passcode": passcode, "Status_Created_At": status['Created_At']},
                                           sort=[("Pointer", 1)])), 'Feel free to try any of the below.'

    # Get the entries that will be generated by what method

    entries_calculated, entries_chosen_by_algorithm, entries_chosen_by_Tags, entries_generated_by_AI = calculate_entries(
        passcode)

    if not entries_calculated:  # If for any reason the function above didn't produce the right results, we end this early

        return False, None, 'Something went wrong, recommendations not able to be generated'

    recommendations_given = 0

    recommendations_given += generate_recommendations_by_AI(passcode, entries_generated_by_AI)

    recommendations_given += generate_recommendations_chosen_by_tags(passcode, entries_chosen_by_Tags)

    recommendations_given += generate_recommendations_by_algorithm(passcode, entries_chosen_by_algorithm)

    return True, list(
        Recommendation_Per_Person.find({"Passcode": passcode, "Status_Created_At": status['Created_At']},
                                       sort=[("Pointer",
                                              1)])), f"Feel free to try any of the {recommendations_given} tasks below."


def generate_recommendation(passcode):

    if not User.find_one(
            {"Passcode": passcode}):  # If we can't find the user we can't generate recommendations for them

        return False, "Something went wrong, user not registered"

    if Recommendation.count_documents({}) == 0:  # If we don't have recommendations we can't return any to the user

        return False, 'There are no recommendations available for you.'

        # Find the last status the user made (look in the function for more) and make sure we enter the right amount if return variables

    today, yesterday, index = get_status(passcode)

    if not today:  # If the user hasn't made a status, we can't generate recommendations for them either

        return False, 'Something went wrong, status was not found'

    status = Status.find_one({"_id": index})  # Find the status to find the timestamp

    entries_requested, additional_entries_via_button = get_maximum_entries()

    if Recommendation_Per_Person.count_documents(
            {"Passcode": passcode, "Status_Created_At": status[
                'Created_At']}) >= entries_requested + additional_entries_via_button:  # A user can't see the whole database daily, so we have limits
        return False, "You have received most available recommendations. No more for now!"

    entries_chosen_by_Tags, entries_chosen_by_algorithm, entries_generated_by_AI = add_category(0, 0, 0)

    if entries_generated_by_AI == 1:

        generate_recommendations_by_AI(passcode, 1)

    elif entries_chosen_by_Tags == 1:

        generate_recommendations_chosen_by_tags(passcode, 1)

    else:

        generate_recommendations_by_algorithm(passcode, 1)

    return True, "Recommendation added"



